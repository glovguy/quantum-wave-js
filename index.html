<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
</head>
<body style="text-align:center; margin-left:auto; margin-right:auto;">

<canvas id="draw" width="1265" height="492"></canvas>

<script>
  const canvas = document.querySelector('#draw');
  const ctx = canvas.getContext('2d');

  // canvas.addEventListener('click', onCanvasClick, false);

  function SQR(x) { return x*x; }

  class Complex {
    constructor(re,im) {
      this.re = re;
      this.im = im;
    }
  }

  class Vector {
    constructor(x,y) {
      this.x = x;
      this.y = y;
    }
  }

  // Wave state vars //
  const N_UNIVERSE = 1265;//4000.0;
  const psi = [];

  let tOld = 0;
  let tNow = 1;
  let tNew = 2;


  // Physical constants //
  const sigma = 25;
  const energy = 31100.0;
  const x0 = 0.3 * canvas.width;//200.0;

  const dt_dx2 = 0.006;
  const dx = 0.004;
  const dt = dt_dx2 * SQR(dx);


  // Potential state vars //
  const vLeft = 0;
  const vCenter = 11000.0;
  const vRight = 0;

  const xLeft = 0.45*N_UNIVERSE*dx;
  const xRight = 0.55*N_UNIVERSE*dx;


  // Display vars //
  let animReqId = null;
  const xScale = 3.0;
  const psi2Scale = 14500.0;//(canvas.height * 30.0);
  const nDtPerDisplay = 220;

  const potentialScale = 0.0105;


  function drawCanvas() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = 'lightgrey';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawWave();
    drawPotentialEnergy();
  }

  function drawWave() {
    ctx.beginPath();
    ctx.lineWidth = "2";
    ctx.strokeStyle = "green";
    ctx.moveTo(0,canvas.height);
    for (let x=1; x<canvas.width; x++) {
      const y = canvasLocationY(expectationValue(psi[x][tNow]), psi2Scale);
      ctx.lineTo(x, y);
    }
    ctx.lineTo(psi.length, canvas.height);
    ctx.stroke();
  }

  function drawPotentialEnergy() {
    ctx.beginPath();
    ctx.lineWidth = "1";
    ctx.strokeStyle = "blue";
    ctx.moveTo(0, canvasLocationY(energy,potentialScale));
    ctx.lineTo(canvas.width, canvasLocationY(energy,potentialScale));
    ctx.stroke();

    ctx.moveTo(0, canvasLocationY(vLeft, potentialScale));
    ctx.lineTo(xLeft/dx, canvasLocationY(vLeft, potentialScale));
    ctx.lineTo(xLeft/dx, canvasLocationY(vCenter, potentialScale));
    ctx.lineTo(xRight/dx, canvasLocationY(vCenter, potentialScale));
    ctx.lineTo(xRight/dx, canvasLocationY(vRight, potentialScale));
    ctx.lineTo(canvas.width, canvasLocationY(vRight, potentialScale));
    ctx.stroke();
  }

  function canvasLocationY(value, scale) {
    return canvas.height - scale*value;
  }

  function expectationValue(complexValue) {
    return SQR(complexValue.re) + SQR(complexValue.im);
  }

  function potential(x) {
    if (x < xLeft/dx && x > 0) { return vLeft; }
    if (x >= xLeft/dx && x < xRight/dx) { return vCenter; }
    if (x >= xRight/dx && x < canvas.width/dx) { return vRight; }
  }

  function initialWavePacketAtTimeAndX(time, x) {
    const tS = 0.5*SQR(sigma);
    const t_tS = time/tS;
    const sigmaT = sigma*Math.sqrt(1 + SQR(t_tS));

    const p0 = Math.sqrt(energy);
    const d = 2*p0*time - x + x0;
    const d_sigmaT = d/sigmaT;

    // const phase = p0*(x - x0) - energy*time;
    // const abs = Math.exp(-0.5*SQR(x-x0))/SQR(sigma);
    const phase = SQR(p0)*time - p0*(x - x0) - 0.5*t_tS*SQR(d_sigmaT) + 0.5*Math.atan(t_tS);
    const abs = Math.exp(-0.5*SQR(d_sigmaT))/Math.sqrt(Math.sqrt(Math.PI)*sigmaT);
    const psiExact = new Complex(
      abs*Math.cos(phase),
      abs*Math.cos(phase + Math.PI/2.0)
    );
    return psiExact;
  }

  function initialWavePacketAtX(x) {
    const psiOld = initialWavePacketAtTimeAndX(-dt, x);
    const psiNow = initialWavePacketAtTimeAndX(0, x);
    const psiNew = initialWavePacketAtTimeAndX(dt, x);

    const wave = {};
    wave[tNow] = psiNow;
    wave[tNew] = psiNew;
    wave[tOld] = psiOld;
    return wave;
  }

  function eventLocationOnCanvas(event) {
    const rect = canvas.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    return new Vector(x,y);
  }

  function evolve() {
    for (let iter=0; iter<nDtPerDisplay; iter++) {
      for (let x=1; x<N_UNIVERSE; x++) {
        const laplace = new Complex(
          2.0*dt_dx2 * (psi[x-1][tNow].re - 2.0*psi[x][tNow].re + psi[x+1][tNow].re),
          2.0*dt_dx2 * (psi[x-1][tNow].im - 2.0*psi[x][tNow].im + psi[x+1][tNow].im)
        );
        psi[x][tNew].re = psi[x][tOld].re - laplace.im + 2.0*dt*potential(x)*psi[x][tNow].im;
        psi[x][tNew].im = psi[x][tOld].im + laplace.re - 2.0*dt*potential(x)*psi[x][tNow].re;
      }

      const _tOld = tOld;
      tOld = tNow;
      tNow = tNew;
      tNew = _tOld;
    }
    drawCanvas();
    animReqId = requestAnimFrame(evolve);
  }

  for (let x=1; x<N_UNIVERSE; x++) {
    psi[x] = initialWavePacketAtX(x);
  }
  psi[0] = {
    0: new Complex(0,0),
    1: new Complex(0,0),
    2: new Complex(0,0)
  }
  psi[N_UNIVERSE] = {
    0: new Complex(0,0),
    1: new Complex(0,0),
    2: new Complex(0,0)
  }
  drawCanvas();

  window.requestAnimFrame = (function(){
    return window.requestAnimationFrame  ||
      window.webkitRequestAnimationFrame  ||
      window.mozRequestAnimationFrame     ||
      function( callback ){
        window.setTimeout(callback, 100);
      };
  })();

  requestAnimFrame(evolve);
</script>

</body>
</html>
